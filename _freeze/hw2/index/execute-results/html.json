{
  "hash": "31f5ed843c218bfdfd1cbba170e2ea17",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Assignment 2\"\nauthor: \"Yannick Heibei\"\n---\n\n\n\n\nAssignment 2: Economics Simulation\n\nThis Assignement relied heavily on AI.\n\nFirst, I want to define the default size and mean of the population an then initialize the population.\n\nIn a Scripts file, I defined the gini function to compute this index for the population\n\nThen as a visualisation a histogram of the population is created.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN <-5000 # Default size of the population\nMU<- 10000 # Default mean of the population\nsd_wealth <- 3000\npopulation <- rnorm(N,MU,sd_wealth)\nlibrary(\"ggplot2\")\nsource(\"Scripts/functions.R\")        \ngini(population)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1685451\n```\n\n\n:::\n\n```{.r .cell-code}\nhist(population, main= \"Population\", xlab= \"wealth\", ylab=\"count\", breaks = 25)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\n\nNow what will happen, when two agents meet?\n\n**Transactions**\n\nFirst I define what happens in a transaction, a random split. As an example, two shares of 100 are split:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_split <- function(A, B) {\n  \n  # Ensure that A and B are not NULL or NA\n  if (is.null(A) || length(A) == 0 || is.na(A)) A <- 0\n  if (is.null(B) || length(B) == 0 || is.na(B)) B <- 0\n  \n  # Calculate the total pot\n  pot <- A + B\n \n# Handle case where both actors have no wealth (pot = 0)\n  if (pot == 0) {\n    return(c(0, 0))  # Both actors get nothing\n  }    \n  # Generate a random share between 0 and the total pot\n  share <- runif(1, 0, pot)\n  \n  # Return the two shares (first actor and second actor)\n  return(c(share, pot - share))\n}\nrandom_split(100,100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  50.26935 149.73065\n```\n\n\n:::\n:::\n\n\n\n\n**Interactions**\n\nTwo different actors shall be randomly picked from the population\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanyone <- function(N) {\n  sample(0:(N-1), 2)  \n}\n\nN <- 5000 \nanyone(N)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3363 1576\n```\n\n\n:::\n:::\n\n\n\n\n**Simulation**\n\nIn order to run the simulation, there needs to be a function defining each single step. Two actors meet, their wealth is split and both leave the interaction with updated wealth.\n\nThis step shall be repeated for T steps.\n\nas output the results of every step shall be printed.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to perform a single step in the simulation\nstep <- function(population, transaction = random_split, interaction = anyone) {\n  indices <- interaction(length(population))  # Select two actors\n  i <- indices[1]\n  j <- indices[2]\n  \n  # Split the wealth between the two actors\n  new_wealth <- transaction(population[i], population[j])\n  \n  # Update population with new wealth\n  population[i] <- new_wealth[1]\n  population[j] <- new_wealth[2]\n  \n  return(population)\n}\n\n# Function to simulate the population over T transactions\nsimulate <- function(population, T, step_function = step, transaction = random_split, interaction = anyone) {\n  # Create a copy of the population to avoid modifying the original\n  population_history <- list(population)\n  \n  # Iterate through each time step\n  for (t in 1:T) {\n    population <- step_function(population, transaction, interaction)\n    population_history[[length(population_history) + 1]] <- population\n  }\n  \n  return(population_history)  # Return the full history of population\n}\n\n# Example: Simulating a population of 4 actors for 8 time steps\npopulation <- rep(100, 4)  # Initial population where each actor has 100 wealth\nT <- 8  # Number of time steps\n\n# Run the simulation\nsimulation_result <- simulate(population, T)\n\n# Print the result of each step in the simulation\nfor (pop in simulation_result) {\n  print(pop)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 100 100 100 100\n[1] 100.000000 190.666357   9.333643 100.000000\n[1] 228.856852  61.809505   9.333643 100.000000\n[1] 228.856852  49.510849   9.333643 100.000000\n[1] 239.843544  38.524158   9.333643 100.000000\n[1] 239.843544   9.805652   9.333643 100.000000\n[1] 239.843544   4.335349  14.803946 100.000000\n[1] 239.8435437   0.5212126  18.6180830 100.0000000\n[1] 239.8435437   0.4725872  18.6180830 100.0000000\n```\n\n\n:::\n:::\n\n\n\n\n**Simulation Visualization**\n\nIf many steps occur, better visualisation is needed, i.e. ordered curves, a printout, histogram and percentile plots.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the function to calculate percentiles\npercent <- function(pct, items) {\n  sorted_items <- sort(items, na.last = TRUE)\n  index <- min(length(sorted_items), ceiling(length(sorted_items) * pct / 100))\n  return(sorted_items[index])\n}\n\n# Define the show function for visualization\nshow <- function(population, k = 40, percentiles = c(1, 10, 50, 90, 99)) {\n  N <- length(population)\n  start <- population\n  results <- list()\n\n  # Run simulation and collect results at intervals\n  for (t in seq(0, k * N, by = N / 10)) {\n    pop <- simulate(population, T = k * N)\n    results[[length(results) + 1]] <- list(t = t, pop = sort(as.numeric(pop[[t + 1]])))  # Ensure pop is numeric and sorted\n  }\n\n  # Print statistics\n  cat('   t    Gini stdev', paste(sprintf(\"%3d%%\", percentiles), collapse = \" \"), \"\\n\")\n  cat('------- ---- -----', paste(rep('----', length(percentiles)), collapse = \" \"), \"\\n\")\n  \n  for (result in results) {\n    t <- result$t\n    pop <- result$pop\n    if (t %% (k * N / 10) == 0) {\n      data <- sapply(percentiles, percent, items = pop)\n      cat(sprintf('%7d %.2f %.1f', t, gini(pop), sd(pop)), data, \"\\n\")\n    }\n  }\n\n  # Prepare data for plotting percentiles\n  percent_plot_data <- data.frame()\n  for (result in results) {\n    t <- result$t\n    pop <- result$pop\n    percent_values <- sapply(percentiles, percent, items = pop)\n    percent_plot_data <- rbind(percent_plot_data, c(t, percent_values))\n  }\n  \n  colnames(percent_plot_data) <- c(\"t\", paste0(\"pct_\", percentiles))\n  \n  # Plot using ggplot2\n  percent_plot_data_long <- reshape(percent_plot_data, varying = paste0(\"pct_\", percentiles),\n                                     v.names = \"percentile\", timevar = \"percentile_type\",\n                                     times = percentiles, direction = \"long\")\n  \n  ggplot(percent_plot_data_long, aes(x = percentile, y = t, color = as.factor(percentile_type))) +\n    geom_line() +\n    labs(title = \"Percentile Plots\", x = \"Wealth\", y = \"Time\") +\n    theme_minimal() +\n    scale_color_discrete(name = \"Percentiles\") +\n    theme(legend.position = \"bottom\")\n\n  # Histograms\n  par(mfrow = c(1, 2))\n  hist(start, main = \"Histogram of Start Wealth\", xlab = \"Wealth\", col = \"lightblue\", breaks = 10)\n  hist(pop, main = \"Histogram of End Wealth\", xlab = \"Wealth\", col = \"lightgreen\", breaks = 10)\n\n  # Ordered Curves\n  order <- seq_along(pop)\n  plot(sort(start), order, type = 'l', col = \"blue\", xlab = \"Wealth\", ylab = \"Order\", \n       main = \"Ordered Curves\")\n  lines(sort(pop), order, col = \"red\")\n  legend(\"topleft\", legend = c(\"Start\", \"End\"), col = c(\"blue\", \"red\"), lty = 1)\n  grid()\n}\n\n# Example usage\npopulation <- rep(100, 4)  # Initial population of 4 actors with wealth of 100 each\nshow(population)  # Run the show function to visualize results\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   t    Gini stdev   1%  10%  50%  90%  99% \n------- ---- ----- ---- ---- ---- ---- ---- \n      0 0.00 0.0 100 100 100 100 100 \n     16 0.46 41.4 7.807212 7.807212 17.8463 100 100 \n     32 0.71 48.9 0.2767724 0.2767724 0.9071314 100 100 \n     48 0.69 48.4 0.03903079 0.03903079 3.561609 100 100 \n     64 0.74 49.8 0.183118 0.183118 0.3110197 100 100 \n     80 0.75 50.0 0.002745791 0.002745791 0.003775999 100 100 \n     96 0.75 50.0 6.484818e-06 6.484818e-06 1.570798e-05 100 100 \n    112 0.75 50.0 0.0001671038 0.0001671038 0.002142176 100 100 \n    128 0.75 50.0 6.613367e-05 6.613367e-05 7.78599e-05 100 100 \n    144 0.75 50.0 1.848457e-08 1.848457e-08 2.893865e-08 100 100 \n    160 0.75 50.0 0.0003454567 0.0003454567 0.0004918122 100 100 \n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n:::\n\n\n\n\nThis didn't work out exactly as planned, lets try again:\n\n**Second Try**\n\nSince I hit a wall, I asked my colleague Thomas Walker for help and he was so kind as to share his code with me, so I will try to follow his steps in the following section:\n\nThis part looks pretty similar. The parameters of the population get defined and a historgam is produced, with a label of the gini index next to the histogram.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN  <- 5000 # Population\nMU <- 100. # Mean of the Population\nstd_dev <- MU/5 # Standard deviation\n\npopulation <- rnorm(N, mean = MU, sd = std_dev)\n\nhist(population, breaks = 50, main = \"Random Gaussian Distribution\", xlab = \"Value\", col = \"skyblue\")\ngini_text <- round(gini(population),4)\ntext(x = 150, y = 400, labels = paste(gini_text), col = \"skyblue\", cex = 1.5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n\nThomas now defines the gini function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngini <- function(y) {\n  # Sort the population\n  y <- sort(y)\n  \n  # Number of elements\n  n <- length(y)\n  \n  # Calculate the Gini coefficient\n  numer <- 2 * sum((1:n) * y)\n  denom <- n * sum(y)\n  \n  # Return the Gini coefficient\n  return((numer / denom) - (n + 1) / n)\n}\n```\n:::\n\n\n\n\nThomas adds his previous actions together and computes the gini index of the population.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngini(population)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1131491\n```\n\n\n:::\n:::\n\n\n\n\nas a next step Thomas defines the random split function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_split <- function(x,y) {\n  # Sum them up\n  pot <- x+y\n  \n  #how to share\n  part1 <- sample(0:pot, 1)\n  \n  #calcutlating the  split \n  part2 <- pot - part1\n  \n  # Return the Gini coefficient\n  return(c(part1, part2))\n}\nrandom_split(70,30)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21 79\n```\n\n\n:::\n:::\n\n\n\n\nHe also defines the anyone function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanyone <- function(x){\n  sample(0:N, 2)\n}\n\nanyone(N) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  824 2522\n```\n\n\n:::\n:::\n\n\n\n\nThomas follows this up with a full-blown simulation.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN  <- 5000 # Population.\nMU <- 100 # Mean of the Population\nstd_dev <- MU/5 # Standard deviation\n\npopulation <- rnorm(N, mean = MU, sd = std_dev)\nround_population <- round(population)\n\n\nanyone <- function(round_population){\n  sample(1:length(round_population), 2)\n}\n\nrandom_split <- function(x,y) {\n  # Sum them up\n  pot <- x+y\n  #how to share\n  part1 <- sample(0:pot, 1)\n  #calcutlating the  split \n  part2 <- pot - part1\n  # Return the Gini coefficient\n  return(c(part1, part2))\n}\n\nsimulation <- function(round_population,repetitions) {\n  for (i in 1:repetitions) {\n      selected_people <- anyone(round_population)\n      #getting the people for trading\n      person1 <- round_population[selected_people[1]]\n      person2 <- round_population[selected_people[2]]\n      #making the new wealth distribution between those two\n      new_wealth <- random_split(person1, person2)\n      #overwriting the old bank statement with the new one\n      round_population[selected_people[1]] <- new_wealth[1]\n      round_population[selected_people[2]] <- new_wealth[2]\n      \n  }\n  return(round_population)\n}\n\nrepetitions <- 10000\n\nfinal_population <- simulation(round_population, repetitions)\n\nhist(final_population, breaks = 50, main = \"After Simulation Grapn\", xlab = \"Value\", col = \"skyblue\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n\nIncredible, I'm at a loss for words. Nothing but respect for Thomas.\n\n```         \n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}